/**
 * Authentication = Identify user
 * AUthorization = Determine user permissions 
 */

 /**
  * New Endpoints
  * 
  * Register: POST  /api/users { name, email, password }
  *   UserSchema: {
  *     email: {
  *       type: String,
  *       unique: true <- ensure unique users
  *     }
  *   }
  * 
  * 
  * Login:    POST  /api/logins
  */

  /**
   * Password Complexity Enforcement
   * 
   * npm install joi-password-complexity
   */

   /**
    * Hash Password
    * 
    * salt = a random string added before or after a password so the resulting
    *         hashed password is different based on the salt used
    * 
    * bcrypt uses original salt to decrypt hashed password, hence why salt is included in hash:
    *   bcrypt.compare(req.body.password, user.password)
    *   - user.password has original salt which is used to hash the req.body.password
    *   - bcrypt then compares the two values to see if they match
    */

    /**
     * jwt = JSON Web Token (www.jwt.io)
     * - a long string that identifies a user
     * - string represents a JSON object which contains the user information
     * - generated by the server, returned to the client
     * - client stores (in local storage) the jwt and uses it for future api calls
     * 
     * - has 3 parts: header, payload (user info), signature
     * signature: generated with private key which is stored only on the server
     * 
     *           //---------------PAYLOAD------------//      //----Secret Key----//
     * jwt.sign({ _id: this._id, isAdmin: this.isAdmin }, config.get('jwtPrivateKey'));
     * 
     * - never store jwt private key in public file
     */

  /**
   * Protect routes with auth middleware
   * 
   * NOTICE: the post() method has 3 arguments
      1) route
      2) auth middleware, which protects the route
      3) callback

      router.post('/', auth, async (req, res) => {
        const { error } = validate(req.body); 
        if (error) return res.status(400).send(error.details[0].message);

        let genre = new Genre({ name: req.body.name });
        genre = await genre.save();
        
        res.send(genre);
      });
   */

   /**
    * LOGOUT a user
    * 
    * - to logout a user, just delete the token on the front-end
    * 
    * - never store tokens on the server or in the db, even if they are hashed
    * 
    * 
    */

 const config = require('config');
 const dotenv = require('dotenv');
 const Joi = require('joi');
 Joi.objectId = require('joi-objectid')(Joi);
 const mongoose = require('mongoose');
 const genres = require('./routes/genres');
 const customers = require('./routes/customers');
 const movies = require('./routes/movies');
 const rentals = require('./routes/rentals');
 const users = require('./routes/users');
 const auth = require('./routes/auth');
 const express = require('express');
 const app = express();
 
 dotenv.config();

 if (!process.env.jwtPrivateKey) {
   console.error('FATAL ERROR: jwtPrivateKey is not defined.');
   process.exit(1);
 }
 
 mongoose.connect('mongodb://localhost/vidly')
   .then(() => console.log('Connected to MongoDB...'))
   .catch(err => console.error('Could not connect to MongoDB...'));
 
 app.use(express.json());
 app.use('/api/genres', genres);
 app.use('/api/customers', customers);
 app.use('/api/movies', movies);
 app.use('/api/rentals', rentals);
 app.use('/api/users', users);
 app.use('/api/auth', auth);
 
 const port = process.env.PORT || 3000;
 app.listen(port, () => console.log(`Listening on port ${port}...`));